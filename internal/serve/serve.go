package serve

import (
	"context"
	"log"

	"github.com/go-openapi/loads"
	"github.com/go-openapi/runtime/middleware"

	"github.com/practable/status/internal/config"
	"github.com/practable/status/internal/serve/restapi"
	"github.com/practable/status/internal/serve/models"
	"github.com/practable/status/internal/serve/restapi/operations"
)

// This file was generated by the swagger tool.
// Make sure not to overwrite this file after you generated it because all your edits would be lost!

func API(ctx context.Context, config config.Config) {
	defer func() {
		log.Trace("serve.API stopped")
	}()

	swaggerSpec, err := loads.Embedded(restapi.SwaggerJSON, restapi.FlatSwaggerJSON)
	if err != nil {
		log.Fatalln(err)
	}

	api := operations.NewServeAPI(swaggerSpec)
	server := restapi.NewServer(api)

	server.Port = config.Port

	// set the Handlers
	api.StatusExperimentsHandler = operations.StatusExperimentsHandlerFunc(statusExperimentsHandler(config))

	go func() {
		defer func() {
			log.Trace("status.serve.API cancel checker goro stopped")
		}()
		log.Trace("status.serve.API awaiting context cancellation")
		<-ctx.Done()
		log.Trace("status.serve.API context cancelled")
		if err := server.Shutdown(); err != nil {
			log.Fatalln(err)
		}

	}()

	server.ConfigureAPI()

	if err := server.Serve(); err != nil {
		log.Fatalln(err)
	}

	log.Trace("status.serve.API stopped without error")

}

func statusExperimentsHandler(s config.Status) func(operations.StatusExperimentsParams) middleware.Responder {

	// convert current status into models version

	sm := []*models.ExperimentStatus
	for _, v := range s.Experiments {
		r := models.ExperimentStatus{
			Address
		}
		
	}

	// return
	return operations.NewStatusExperimentsOK.WithPayload(sm)

}
